# Dependency Injection with Wire

This package uses [Google Wire](https://github.com/google/wire) for compile-time dependency injection.

## Overview

Wire generates code that wires together your application's dependencies at compile time, providing:
- **Type safety**: All dependencies are checked at compile time
- **No runtime reflection**: Generated code is plain Go functions
- **Clear dependency graph**: Easy to understand and debug
- **Explicit wiring**: No hidden magic or configuration files

## File Structure

- `providers.go` - Infrastructure providers (DB, services, repositories)
- `usecases.go` - Use case provider sets
- `handlers.go` - HTTP handler provider sets
- `app.go` - Application container struct and constructor
- `wire.go` - Wire injector declaration (build tag: `wireinject`)
- `wire_gen.go` - **Generated by Wire** (build tag: `!wireinject`)

## Usage

### Generating Wire Code

After modifying providers or adding new dependencies, regenerate the Wire code:

```bash
make wire
```

Or manually:

```bash
cd internal/di && wire
```

### Checking Wire Configuration

To validate your Wire configuration without generating code:

```bash
make wire-check
```

## Adding New Dependencies

### 1. Add a Repository

**Step 1:** Add provider function in `providers.go`:
```go
func ProvideMyRepository(db *pgxpool.Pool) ports.MyRepository {
    return repositories.NewMyRepositoryImpl(db)
}
```

**Step 2:** Add to `ProviderSet` in `providers.go`:
```go
var ProviderSet = wire.NewSet(
    // ... existing providers
    ProvideMyRepository,
)
```

**Step 3:** Regenerate Wire code:
```bash
make wire
```

### 2. Add a Use Case

**Step 1:** Add to appropriate provider set in `usecases.go`:
```go
var MyFeatureUsecaseSet = wire.NewSet(
    myfeature.NewCreateMyFeatureUsecase,
    myfeature.NewGetMyFeatureUsecase,
    // ... more use cases
)
```

**Step 2:** Add the set to `ProviderSet` in `providers.go`:
```go
var ProviderSet = wire.NewSet(
    // ... existing providers
    MyFeatureUsecaseSet,
)
```

**Step 3:** Regenerate:
```bash
make wire
```

### 3. Add a Handler

**Step 1:** Add to `HandlerSet` in `handlers.go`:
```go
var HandlerSet = wire.NewSet(
    // ... existing handlers
    myfeature.NewMyFeatureHandler,
)
```

**Step 2:** Add handler to `App` struct in `app.go`:
```go
type App struct {
    // ... existing handlers
    MyFeatureHandler *myfeature.MyFeatureHandler
}
```

**Step 3:** Add parameter to `NewApp` function in `app.go`:
```go
func NewApp(
    // ... existing parameters
    myFeatureHandler *myfeature.MyFeatureHandler,
) *App {
    return &App{
        // ... existing fields
        MyFeatureHandler: myFeatureHandler,
    }
}
```

**Step 4:** Regenerate:
```bash
make wire
```

## Build Tags

Wire uses Go build tags to separate injector declarations from generated code:

- `wireinject` - Only includes `wire.go` (the declaration)
- `!wireinject` - Only includes `wire_gen.go` (the generated implementation)

This ensures that during normal builds, only the generated code is used, while `wire` command uses the declaration.

## Best Practices

1. **Never edit `wire_gen.go` manually** - It's automatically generated
2. **Keep providers simple** - One responsibility per provider function
3. **Use provider sets** - Group related providers (e.g., all car use cases)
4. **Regenerate after changes** - Always run `make wire` after modifying providers
5. **Commit generated code** - Include `wire_gen.go` in version control

## Troubleshooting

### "unused provider" error
- Remove or comment out unused providers from `ProviderSet`
- Or add the dependency to a handler/use case that uses it

### "no provider found" error
- Add the missing provider function
- Make sure it's included in a provider set
- Ensure the provider set is in `ProviderSet`

### Type mismatch errors
- Check that interface implementations match their ports
- Verify function signatures match expected types

### Circular dependency error
- Restructure your dependencies to avoid cycles
- Consider using an interface to break the cycle

## Example: Full Feature Addition

```go
// 1. providers.go
func ProvideArticleRepository(db *pgxpool.Pool) ports.ArticleRepository {
    return repositories.NewArticleRepositoryImpl(db)
}

var ProviderSet = wire.NewSet(
    // ...
    ProvideArticleRepository,
    ArticleUsecaseSet,  // Step 2
    HandlerSet,          // Step 3
)

// 2. usecases.go
var ArticleUsecaseSet = wire.NewSet(
    article.NewCreateArticleUsecase,
    article.NewGetArticleUsecase,
    article.NewListArticlesUsecase,
)

// 3. handlers.go
var HandlerSet = wire.NewSet(
    // ...
    article.NewArticleHandler,
)

// 4. app.go
type App struct {
    // ...
    ArticleHandler *article.ArticleHandler
}

func NewApp(
    // ...
    articleHandler *article.ArticleHandler,
) *App {
    return &App{
        // ...
        ArticleHandler: articleHandler,
    }
}
```

Then regenerate: `make wire`

## Resources

- [Wire Documentation](https://github.com/google/wire/blob/main/docs/guide.md)
- [Wire Tutorial](https://github.com/google/wire/blob/main/_tutorial/README.md)
- [Wire Best Practices](https://github.com/google/wire/blob/main/docs/best-practices.md)
